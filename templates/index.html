<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>My AI Assistant</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
  <div class="app-container">
    <!-- Sidebar -->
    <aside id="sidebar" class="sidebar">
      <div class="sidebar-header">
        <button id="sidebar-toggle" class="sidebar-toggle" aria-label="Toggle sidebar">
          <span class="toggle-icon">☰</span>
        </button>
        <h2 class="sidebar-title">Conversations</h2>
      </div>
      <div class="sidebar-content">
        <button id="new-conversation-btn" class="new-conversation-btn">
          <span>+</span> New Conversation
        </button>
        <div id="conversations-list" class="conversations-list">
          <!-- Conversations will be loaded here -->
        </div>
      </div>
      <div class="sidebar-footer">
        <button id="settings-btn" class="settings-btn" aria-label="Settings" title="Settings (Coming Soon)">
          ⚙️
        </button>
      </div>
    </aside>

    <!-- Settings Panel -->
    <aside id="settings-panel" class="settings-panel">
      <div class="settings-header">
        <h2>Settings</h2>
        <button id="settings-close-btn" class="settings-close-btn" aria-label="Close settings">×</button>
      </div>
      <div class="settings-content">
        <div class="settings-section">
          <h3>Model</h3>
          <p class="settings-description">Current model: Gemini 2.5 Flash</p>
          <p class="settings-note">Model selection coming soon</p>
        </div>
        <div class="settings-section">
          <h3>Conversations</h3>
          <p class="settings-description">Manage your conversation history</p>
          <button id="clear-all-conversations-btn" class="settings-action-btn">Clear All Conversations</button>
        </div>
        <div class="settings-section">
          <h3>About</h3>
          <p class="settings-description">My AI Assistant v1.0</p>
          <p class="settings-note">Powered by Gemini 2.5 Flash</p>
        </div>
      </div>
    </aside>

    <!-- Settings Overlay -->
    <div id="settings-overlay" class="settings-overlay"></div>

    <!-- Main Content -->
    <main class="app">
      <!-- Floating toggle button (visible when sidebar is collapsed) -->
      <button id="sidebar-toggle-floating" class="sidebar-toggle-floating" aria-label="Toggle sidebar" style="display: none;">
        <span class="toggle-icon">☰</span>
      </button>
      <section class="card">
        <header>
          <h1>My AI Assistant</h1>
          <p>Backed by Gemini 2.5 Flash. Ask anything related to research, code, or explanations.</p>
        </header>

        <section id="chat" class="chat">
          <div class="msg-row assistant">
            <div class="bubble">
              <div class="role-label">Assistant</div>
              Hello! I'm here and ready to help.  
              How can I assist you today?
            </div>
          </div>
        </section>

        <form id="prompt-form" class="input-area">
          <textarea
            id="prompt"
            placeholder="Ask me anything… (Shift+Enter for newline)"
          ></textarea>
          <button type="submit" id="send-btn">Send</button>
        </form>

        <div class="status" id="status">
          Ready.
        </div>
      </section>
    </main>
  </div>

  <script>
    // State management
    let currentConversationId = sessionStorage.getItem('conversation_id') || null;

    // DOM elements
    const form = document.getElementById('prompt-form');
    const promptInput = document.getElementById('prompt');
    const chat = document.getElementById('chat');
    const statusEl = document.getElementById('status');
    const sendBtn = document.getElementById('send-btn');
    const sidebar = document.getElementById('sidebar');
    const sidebarToggle = document.getElementById('sidebar-toggle');
    const newConversationBtn = document.getElementById('new-conversation-btn');
    const conversationsList = document.getElementById('conversations-list');

    const sidebarToggleFloating = document.getElementById('sidebar-toggle-floating');
    const settingsBtn = document.getElementById('settings-btn');
    const settingsPanel = document.getElementById('settings-panel');
    const settingsOverlay = document.getElementById('settings-overlay');
    const settingsCloseBtn = document.getElementById('settings-close-btn');
    const clearAllConversationsBtn = document.getElementById('clear-all-conversations-btn');
    
    // Function to toggle sidebar
    function toggleSidebar() {
      sidebar.classList.toggle('collapsed');
      // Show/hide floating toggle button
      if (sidebar.classList.contains('collapsed')) {
        sidebarToggleFloating.style.display = 'flex';
      } else {
        sidebarToggleFloating.style.display = 'none';
      }
    }
    
    // Function to open settings
    function openSettings() {
      settingsPanel.classList.add('active');
      settingsOverlay.classList.add('active');
      document.body.style.overflow = 'hidden'; // Prevent background scrolling
    }
    
    // Function to close settings
    function closeSettings() {
      settingsPanel.classList.remove('active');
      settingsOverlay.classList.remove('active');
      document.body.style.overflow = ''; // Restore scrolling
    }
    
    // Sidebar toggle (both buttons)
    sidebarToggle.addEventListener('click', toggleSidebar);
    sidebarToggleFloating.addEventListener('click', toggleSidebar);
    
    // Settings panel controls
    settingsBtn.addEventListener('click', openSettings);
    settingsCloseBtn.addEventListener('click', closeSettings);
    settingsOverlay.addEventListener('click', closeSettings);
    
    // Clear all conversations
    clearAllConversationsBtn.addEventListener('click', async () => {
      if (confirm('Are you sure you want to delete ALL conversations? This cannot be undone.')) {
        try {
          const resp = await fetch('/conversations');
          if (!resp.ok) throw new Error('Failed to load conversations');
          const data = await resp.json();
          const conversations = data.conversations || [];
          
          // Delete each conversation
          for (const conv of conversations) {
            await fetch(`/conversations/${conv.id}`, { method: 'DELETE' });
          }
          
          // Clear current conversation
          currentConversationId = null;
          sessionStorage.removeItem('conversation_id');
          clearChat();
          await loadConversations();
          closeSettings();
          statusEl.textContent = 'All conversations deleted.';
        } catch (err) {
          console.error('Error clearing conversations:', err);
          statusEl.textContent = 'Error clearing conversations.';
        }
      }
    });

    // Format date for display
    function formatDate(dateString) {
      const date = new Date(dateString);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);

      if (diffMins < 1) return 'Just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays < 7) return `${diffDays}d ago`;
      return date.toLocaleDateString();
    }

    // Load conversations list
    async function loadConversations() {
      try {
        const resp = await fetch('/conversations');
        if (!resp.ok) throw new Error('Failed to load conversations');
        const data = await resp.json();
        renderConversationsList(data.conversations || []);
      } catch (err) {
        console.error('Error loading conversations:', err);
      }
    }

    // Render conversations list
    function renderConversationsList(conversations) {
      conversationsList.innerHTML = '';
      
      if (conversations.length === 0) {
        conversationsList.innerHTML = '<div class="empty-state">No conversations yet</div>';
        return;
      }

      conversations.forEach(conv => {
        const item = document.createElement('div');
        item.className = `conversation-item ${conv.id === currentConversationId ? 'active' : ''}`;
        item.innerHTML = `
          <div class="conversation-info" data-id="${conv.id}">
            <div class="conversation-title">${conv.message_count > 0 ? `Conversation (${conv.message_count} messages)` : 'New Conversation'}</div>
            <div class="conversation-date">${formatDate(conv.updated_at || conv.created_at)}</div>
          </div>
          <button class="delete-conversation-btn" data-id="${conv.id}" aria-label="Delete conversation">×</button>
        `;
        
        // Click to load conversation
        item.querySelector('.conversation-info').addEventListener('click', () => {
          loadConversation(conv.id);
        });
        
        // Delete conversation
        item.querySelector('.delete-conversation-btn').addEventListener('click', async (e) => {
          e.stopPropagation();
          if (confirm('Delete this conversation?')) {
            await deleteConversation(conv.id);
          }
        });
        
        conversationsList.appendChild(item);
      });
    }

    // Create new conversation
    async function createNewConversation() {
      try {
        const resp = await fetch('/conversations/new', { method: 'POST' });
        if (!resp.ok) throw new Error('Failed to create conversation');
        const data = await resp.json();
        currentConversationId = data.conversation_id;
        sessionStorage.setItem('conversation_id', currentConversationId);
        clearChat();
        await loadConversations();
        statusEl.textContent = 'New conversation started.';
      } catch (err) {
        console.error('Error creating conversation:', err);
        statusEl.textContent = 'Error creating conversation.';
      }
    }

    // Load a conversation
    async function loadConversation(conversationId) {
      try {
        const resp = await fetch(`/conversations/${conversationId}`);
        if (!resp.ok) throw new Error('Failed to load conversation');
        const data = await resp.json();
        
        currentConversationId = conversationId;
        sessionStorage.setItem('conversation_id', conversationId);
        
        // Clear and reload chat
        clearChat();
        data.messages.forEach(msg => {
          appendMessage(msg.role, msg.content);
        });
        
        await loadConversations();
        statusEl.textContent = 'Conversation loaded.';
      } catch (err) {
        console.error('Error loading conversation:', err);
        statusEl.textContent = 'Error loading conversation.';
      }
    }

    // Delete a conversation
    async function deleteConversation(conversationId) {
      try {
        const resp = await fetch(`/conversations/${conversationId}`, { method: 'DELETE' });
        if (!resp.ok) throw new Error('Failed to delete conversation');
        
        if (conversationId === currentConversationId) {
          currentConversationId = null;
          sessionStorage.removeItem('conversation_id');
          clearChat();
        }
        
        await loadConversations();
        statusEl.textContent = 'Conversation deleted.';
      } catch (err) {
        console.error('Error deleting conversation:', err);
        statusEl.textContent = 'Error deleting conversation.';
      }
    }

    // Clear chat display
    function clearChat() {
      chat.innerHTML = `
        <div class="msg-row assistant">
          <div class="bubble">
            <div class="role-label">Assistant</div>
            Hello! I'm here and ready to help.  
            How can I assist you today?
          </div>
        </div>
      `;
    }

    // Append message to chat
    function appendMessage(role, content, isTyping = false) {
      const row = document.createElement('div');
      row.className = `msg-row ${role}`;

      const bubble = document.createElement('div');
      bubble.className = 'bubble';

      const label = document.createElement('div');
      label.className = 'role-label';
      label.textContent = role === 'user' ? 'You' : 'Assistant';

      bubble.appendChild(label);

      if (isTyping) {
        const dots = document.createElement('div');
        dots.style.display = 'flex';
        dots.style.gap = '4px';
        ['dot1', 'dot2', 'dot3'].forEach(() => {
          const d = document.createElement('div');
          d.className = 'typing-dot';
          dots.appendChild(d);
        });
        bubble.appendChild(dots);
      } else {
        bubble.appendChild(document.createTextNode(content));
      }

      row.appendChild(bubble);
      chat.appendChild(row);
      chat.scrollTop = chat.scrollHeight;
      return row;
    }

    // Handle form submission
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const prompt = promptInput.value.trim();
      if (!prompt) return;

      appendMessage('user', prompt);
      promptInput.value = '';
      sendBtn.disabled = true;
      statusEl.textContent = 'Thinking…';

      const typingRow = appendMessage('assistant', '', true);

      try {
        const resp = await fetch('/ask', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            prompt,
            conversation_id: currentConversationId
          })
        });

        if (!resp.ok) {
          // Read response body as text first (can only be read once)
          const responseText = await resp.text();
          let errorMessage = `HTTP ${resp.status}`;
          try {
            // Try to parse as JSON
            const errData = JSON.parse(responseText);
            errorMessage = errData.error || errorMessage;
          } catch {
            // If JSON parsing fails, use the text directly
            errorMessage = responseText || resp.statusText || errorMessage;
          }
          throw new Error(errorMessage);
        }

        const data = await resp.json();
        const answer = data.response || '[No response returned]';
        
        // Update conversation ID if returned
        if (data.conversation_id) {
          currentConversationId = data.conversation_id;
          sessionStorage.setItem('conversation_id', currentConversationId);
          await loadConversations();
        }

        typingRow.remove();
        appendMessage('assistant', answer);
        statusEl.textContent = 'Ready.';
      } catch (err) {
        console.error(err);
        typingRow.remove();
        appendMessage('assistant',
          'Sorry, something went wrong while contacting the backend. ' +
          'Check the server logs for details.'
        );
        statusEl.textContent = `Error: ${err.message}`;
      } finally {
        sendBtn.disabled = false;
        chat.scrollTop = chat.scrollHeight;
      }
    });

    promptInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        form.dispatchEvent(new Event('submit'));
      }
    });

    // Initialize
    newConversationBtn.addEventListener('click', createNewConversation);
    
    // Load conversations and current conversation on page load
    (async () => {
      await loadConversations();
      if (currentConversationId) {
        await loadConversation(currentConversationId);
      }
    })();
  </script>
</body>
</html>
