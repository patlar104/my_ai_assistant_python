<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>My AI Assistant</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <!-- Markdown rendering and syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/DOMPurify/3.0.6/purify.min.js"></script>
</head>
<body>
  <div class="app-container">
    <!-- Sidebar -->
    <aside id="sidebar" class="sidebar">
      <div class="sidebar-header">
        <button id="sidebar-toggle" class="sidebar-toggle" aria-label="Toggle sidebar">
          <span class="toggle-icon">‚ò∞</span>
        </button>
        <h2 class="sidebar-title">Conversations</h2>
      </div>
      <div class="sidebar-content">
        <button id="new-conversation-btn" class="new-conversation-btn">
          <span>+</span> New Conversation
        </button>
        <div id="conversations-list" class="conversations-list">
          <!-- Conversations will be loaded here -->
        </div>
      </div>
      <div class="sidebar-footer">
        <button id="settings-btn" class="settings-btn" aria-label="Settings" title="Settings (Coming Soon)">
          ‚öôÔ∏è
        </button>
      </div>
    </aside>

    <!-- Settings Panel -->
    <aside id="settings-panel" class="settings-panel">
      <div class="settings-header">
        <h2>Settings</h2>
        <button id="settings-close-btn" class="settings-close-btn" aria-label="Close settings">√ó</button>
      </div>
      <div class="settings-content">
        <div class="settings-section">
          <h3>Model</h3>
          <p class="settings-description">Current model: Gemini 2.5 Flash</p>
          <p class="settings-note">Model selection coming soon</p>
        </div>
        <div class="settings-section">
          <h3>Response Settings</h3>
          <div class="settings-control-group">
            <label for="temperature-slider" class="settings-label">
              Temperature: <span id="temperature-value">0.7</span>
              <span class="settings-hint">Controls creativity (0.0 = focused, 2.0 = creative)</span>
            </label>
            <input type="range" id="temperature-slider" class="settings-slider" min="0" max="2" step="0.1" value="0.7">
          </div>
          <div class="settings-control-group">
            <label for="max-tokens-input" class="settings-label">
              Max Tokens: <span id="max-tokens-value">2048</span>
              <span class="settings-hint">Maximum response length (256-8192)</span>
            </label>
            <input type="range" id="max-tokens-slider" class="settings-slider" min="256" max="8192" step="256" value="2048">
            <input type="number" id="max-tokens-input" class="settings-number-input" min="256" max="8192" step="256" value="2048">
          </div>
        </div>
        <div class="settings-section">
          <h3>Conversations</h3>
          <p class="settings-description">Manage your conversation history</p>
          <button id="clear-all-conversations-btn" class="settings-action-btn">Clear All Conversations</button>
        </div>
        <div class="settings-section">
          <h3>About</h3>
          <p class="settings-description">My AI Assistant v1.0</p>
          <p class="settings-note">Powered by Gemini 2.5 Flash</p>
        </div>
      </div>
    </aside>

    <!-- Settings Overlay -->
    <div id="settings-overlay" class="settings-overlay"></div>

    <!-- Main Content -->
    <main class="app">
      <!-- Floating toggle button (visible when sidebar is collapsed) -->
      <button id="sidebar-toggle-floating" class="sidebar-toggle-floating" aria-label="Toggle sidebar" style="display: none;">
        <span class="toggle-icon">‚ò∞</span>
      </button>
      <section class="card">
        <header>
          <h1>My AI Assistant</h1>
          <p>Backed by Gemini 2.5 Flash. Ask anything related to research, code, or explanations.</p>
        </header>

        <section id="chat" class="chat">
          <div class="msg-row assistant">
            <div class="bubble">
              <div class="role-label">Assistant</div>
              Hello! I'm here and ready to help.  
              How can I assist you today?
            </div>
          </div>
        </section>

        <form id="prompt-form" class="input-area">
          <textarea
            id="prompt"
            placeholder="Ask me anything‚Ä¶ (Shift+Enter for newline)"
          ></textarea>
          <button type="submit" id="send-btn">Send</button>
        </form>

        <div class="status" id="status">
          Ready.
        </div>
      </section>
    </main>
  </div>

  <script>
    // State management
    let currentConversationId = sessionStorage.getItem('conversation_id') || null;

    // DOM elements
    const form = document.getElementById('prompt-form');
    const promptInput = document.getElementById('prompt');
    const chat = document.getElementById('chat');
    const statusEl = document.getElementById('status');
    const sendBtn = document.getElementById('send-btn');
    const sidebar = document.getElementById('sidebar');
    const sidebarToggle = document.getElementById('sidebar-toggle');
    const newConversationBtn = document.getElementById('new-conversation-btn');
    const conversationsList = document.getElementById('conversations-list');

    const sidebarToggleFloating = document.getElementById('sidebar-toggle-floating');
    const settingsBtn = document.getElementById('settings-btn');
    const settingsPanel = document.getElementById('settings-panel');
    const settingsOverlay = document.getElementById('settings-overlay');
    const settingsCloseBtn = document.getElementById('settings-close-btn');
    const clearAllConversationsBtn = document.getElementById('clear-all-conversations-btn');
    
    // Function to toggle sidebar
    function toggleSidebar() {
      sidebar.classList.toggle('collapsed');
      // Show/hide floating toggle button
      if (sidebar.classList.contains('collapsed')) {
        sidebarToggleFloating.style.display = 'flex';
      } else {
        sidebarToggleFloating.style.display = 'none';
      }
    }
    
    // Function to open settings
    function openSettings() {
      settingsPanel.classList.add('active');
      settingsOverlay.classList.add('active');
      document.body.style.overflow = 'hidden'; // Prevent background scrolling
    }
    
    // Function to close settings
    function closeSettings() {
      settingsPanel.classList.remove('active');
      settingsOverlay.classList.remove('active');
      document.body.style.overflow = ''; // Restore scrolling
    }
    
    // Sidebar toggle (both buttons)
    sidebarToggle.addEventListener('click', toggleSidebar);
    sidebarToggleFloating.addEventListener('click', toggleSidebar);
    
    // Settings panel controls
    settingsBtn.addEventListener('click', openSettings);
    settingsCloseBtn.addEventListener('click', closeSettings);
    settingsOverlay.addEventListener('click', closeSettings);
    
    // Clear all conversations
    clearAllConversationsBtn.addEventListener('click', async () => {
      if (confirm('Are you sure you want to delete ALL conversations? This cannot be undone.')) {
        try {
          const resp = await fetch('/conversations');
          if (!resp.ok) throw new Error('Failed to load conversations');
          const data = await resp.json();
          const conversations = data.conversations || [];
          
          // Delete each conversation
          for (const conv of conversations) {
            await fetch(`/conversations/${conv.id}`, { method: 'DELETE' });
          }
          
          // Clear current conversation
          currentConversationId = null;
          sessionStorage.removeItem('conversation_id');
          clearChat();
          await loadConversations();
          closeSettings();
          statusEl.textContent = 'All conversations deleted.';
        } catch (err) {
          console.error('Error clearing conversations:', err);
          statusEl.textContent = 'Error clearing conversations.';
        }
      }
    });

    // Format date for display
    function formatDate(dateString) {
      const date = new Date(dateString);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);

      if (diffMins < 1) return 'Just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays < 7) return `${diffDays}d ago`;
      return date.toLocaleDateString();
    }

    // Load conversations list
    async function loadConversations() {
      try {
        const resp = await fetch('/conversations');
        if (!resp.ok) throw new Error('Failed to load conversations');
        const data = await resp.json();
        renderConversationsList(data.conversations || []);
      } catch (err) {
        console.error('Error loading conversations:', err);
      }
    }

    // Render conversations list
    function renderConversationsList(conversations) {
      conversationsList.innerHTML = '';
      
      if (conversations.length === 0) {
        conversationsList.innerHTML = '<div class="empty-state">No conversations yet</div>';
        return;
      }

      conversations.forEach(conv => {
        const item = document.createElement('div');
        item.className = `conversation-item ${conv.id === currentConversationId ? 'active' : ''}`;
        item.innerHTML = `
          <div class="conversation-info" data-id="${conv.id}">
            <div class="conversation-title">${conv.message_count > 0 ? `Conversation (${conv.message_count} messages)` : 'New Conversation'}</div>
            <div class="conversation-date">${formatDate(conv.updated_at || conv.created_at)}</div>
          </div>
          <button class="delete-conversation-btn" data-id="${conv.id}" aria-label="Delete conversation">√ó</button>
        `;
        
        // Click to load conversation
        item.querySelector('.conversation-info').addEventListener('click', () => {
          loadConversation(conv.id);
        });
        
        // Delete conversation
        item.querySelector('.delete-conversation-btn').addEventListener('click', async (e) => {
          e.stopPropagation();
          if (confirm('Delete this conversation?')) {
            await deleteConversation(conv.id);
          }
        });
        
        conversationsList.appendChild(item);
      });
    }

    // Create new conversation
    async function createNewConversation() {
      try {
        const resp = await fetch('/conversations/new', { method: 'POST' });
        if (!resp.ok) throw new Error('Failed to create conversation');
        const data = await resp.json();
        currentConversationId = data.conversation_id;
        sessionStorage.setItem('conversation_id', currentConversationId);
        clearChat();
        await loadConversations();
        statusEl.textContent = 'New conversation started.';
      } catch (err) {
        console.error('Error creating conversation:', err);
        statusEl.textContent = 'Error creating conversation.';
      }
    }

    // Load a conversation
    async function loadConversation(conversationId) {
      try {
        const resp = await fetch(`/conversations/${conversationId}`);
        if (!resp.ok) throw new Error('Failed to load conversation');
        const data = await resp.json();
        
        currentConversationId = conversationId;
        sessionStorage.setItem('conversation_id', conversationId);
        
        // Clear and reload chat
        clearChat();
        data.messages.forEach(msg => {
          appendMessage(msg.role, msg.content);
        });
        
        await loadConversations();
        statusEl.textContent = 'Conversation loaded.';
      } catch (err) {
        console.error('Error loading conversation:', err);
        statusEl.textContent = 'Error loading conversation.';
      }
    }

    // Delete a conversation
    async function deleteConversation(conversationId) {
      try {
        const resp = await fetch(`/conversations/${conversationId}`, { method: 'DELETE' });
        if (!resp.ok) throw new Error('Failed to delete conversation');
        
        if (conversationId === currentConversationId) {
          currentConversationId = null;
          sessionStorage.removeItem('conversation_id');
          clearChat();
        }
        
        await loadConversations();
        statusEl.textContent = 'Conversation deleted.';
      } catch (err) {
        console.error('Error deleting conversation:', err);
        statusEl.textContent = 'Error deleting conversation.';
      }
    }

    // Clear chat display
    function clearChat() {
      chat.innerHTML = `
        <div class="msg-row assistant">
          <div class="bubble">
            <div class="role-label">Assistant</div>
            Hello! I'm here and ready to help.  
            How can I assist you today?
          </div>
        </div>
      `;
    }

    // Configure marked for markdown rendering
    if (typeof marked !== 'undefined') {
      marked.setOptions({
        breaks: true,
        gfm: true,
        highlight: function(code, lang) {
          if (typeof hljs !== 'undefined') {
            if (lang && hljs.getLanguage(lang)) {
              try {
                return hljs.highlight(code, { language: lang }).value;
              } catch (err) {
                // Fall through to auto-detect
              }
            }
            try {
              return hljs.highlightAuto(code).value;
            } catch (err) {
              return code;
            }
          }
          return code;
        }
      });
    }

    // Append message to chat
    function appendMessage(role, content, isTyping = false, messageId = null) {
      const row = document.createElement('div');
      row.className = `msg-row ${role}`;
      if (messageId) {
        row.setAttribute('data-message-id', messageId);
      }

      const bubble = document.createElement('div');
      bubble.className = 'bubble';

      const labelRow = document.createElement('div');
      labelRow.style.display = 'flex';
      labelRow.style.justifyContent = 'space-between';
      labelRow.style.alignItems = 'center';
      labelRow.style.marginBottom = '0.5rem';

      const label = document.createElement('div');
      label.className = 'role-label';
      label.textContent = role === 'user' ? 'You' : 'Assistant';

      labelRow.appendChild(label);

      // Add response controls for assistant messages
      if (role === 'assistant' && !isTyping) {
        const controls = document.createElement('div');
        controls.className = 'message-controls';
        
        const copyBtn = document.createElement('button');
        copyBtn.className = 'message-control-btn';
        copyBtn.setAttribute('aria-label', 'Copy response');
        copyBtn.title = 'Copy';
        copyBtn.innerHTML = 'üìã';
        copyBtn.onclick = (e) => {
          e.stopPropagation();
          copyToClipboard(content);
          copyBtn.innerHTML = '‚úì';
          setTimeout(() => {
            copyBtn.innerHTML = 'üìã';
          }, 2000);
        };
        
        const regenerateBtn = document.createElement('button');
        regenerateBtn.className = 'message-control-btn';
        regenerateBtn.setAttribute('aria-label', 'Regenerate response');
        regenerateBtn.title = 'Regenerate';
        regenerateBtn.innerHTML = 'üîÑ';
        regenerateBtn.onclick = (e) => {
          e.stopPropagation();
          regenerateLastResponse();
        };
        
        controls.appendChild(copyBtn);
        controls.appendChild(regenerateBtn);
        labelRow.appendChild(controls);
      }

      bubble.appendChild(labelRow);

      if (isTyping) {
        const dots = document.createElement('div');
        dots.style.display = 'flex';
        dots.style.gap = '4px';
        ['dot1', 'dot2', 'dot3'].forEach(() => {
          const d = document.createElement('div');
          d.className = 'typing-dot';
          dots.appendChild(d);
        });
        bubble.appendChild(dots);
      } else {
        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        
        if (role === 'assistant' && typeof marked !== 'undefined') {
          // Render markdown for assistant responses
          const rawHtml = marked.parse(content);
          const sanitized = typeof DOMPurify !== 'undefined' 
            ? DOMPurify.sanitize(rawHtml)
            : rawHtml;
          contentDiv.innerHTML = sanitized;
          
          // Highlight code blocks
          if (typeof hljs !== 'undefined') {
            contentDiv.querySelectorAll('pre code').forEach((block) => {
              hljs.highlightElement(block);
            });
          }
        } else {
          // Plain text for user messages
          contentDiv.textContent = content;
        }
        
        bubble.appendChild(contentDiv);
      }

      row.appendChild(bubble);
      chat.appendChild(row);
      chat.scrollTop = chat.scrollHeight;
      return row;
    }

    // Copy to clipboard helper
    function copyToClipboard(text) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(() => {
          statusEl.textContent = 'Copied to clipboard!';
          setTimeout(() => {
            statusEl.textContent = 'Ready.';
          }, 2000);
        });
      } else {
        // Fallback for older browsers
        const textarea = document.createElement('textarea');
        textarea.value = text;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        statusEl.textContent = 'Copied to clipboard!';
        setTimeout(() => {
          statusEl.textContent = 'Ready.';
        }, 2000);
      }
    }

    // Regenerate last response
    let lastPrompt = null;
    async function regenerateLastResponse() {
      if (!lastPrompt) {
        statusEl.textContent = 'No previous prompt to regenerate.';
        return;
      }
      
      sendBtn.disabled = true;
      statusEl.textContent = 'Regenerating‚Ä¶';
      
      // Remove last assistant message
      const lastAssistantMsg = Array.from(chat.querySelectorAll('.msg-row.assistant')).slice(-1)[0];
      if (lastAssistantMsg) {
        lastAssistantMsg.remove();
      }
      
      const typingRow = appendMessage('assistant', '', true);
      
      try {
        const resp = await fetch('/ask', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            prompt: lastPrompt,
            conversation_id: currentConversationId,
            temperature: getTemperature(),
            max_tokens: getMaxTokens()
          })
        });

        if (!resp.ok) {
          const responseText = await resp.text();
          let errorMessage = `HTTP ${resp.status}`;
          try {
            const errData = JSON.parse(responseText);
            errorMessage = errData.error || errorMessage;
          } catch {
            errorMessage = responseText || resp.statusText || errorMessage;
          }
          throw new Error(errorMessage);
        }

        const data = await resp.json();
        const answer = data.response || '[No response returned]';
        
        if (data.conversation_id) {
          currentConversationId = data.conversation_id;
          sessionStorage.setItem('conversation_id', currentConversationId);
          await loadConversations();
        }

        typingRow.remove();
        appendMessage('assistant', answer);
        statusEl.textContent = 'Ready.';
      } catch (err) {
        console.error(err);
        typingRow.remove();
        appendMessage('assistant',
          'Sorry, something went wrong while contacting the backend. ' +
          'Check the server logs for details.'
        );
        statusEl.textContent = `Error: ${err.message}`;
      } finally {
        sendBtn.disabled = false;
        chat.scrollTop = chat.scrollHeight;
      }
    }

    // Get response settings
    function getTemperature() {
      const value = parseFloat(document.getElementById('temperature-slider').value);
      return isNaN(value) ? 0.7 : value;
    }

    function getMaxTokens() {
      const value = parseInt(document.getElementById('max-tokens-input').value);
      return isNaN(value) ? 2048 : value;
    }

    // Load settings from localStorage
    function loadSettings() {
      const savedTemp = localStorage.getItem('temperature');
      const savedMaxTokens = localStorage.getItem('max_tokens');
      
      if (savedTemp) {
        document.getElementById('temperature-slider').value = savedTemp;
        document.getElementById('temperature-value').textContent = savedTemp;
      }
      
      if (savedMaxTokens) {
        document.getElementById('max-tokens-slider').value = savedMaxTokens;
        document.getElementById('max-tokens-input').value = savedMaxTokens;
        document.getElementById('max-tokens-value').textContent = savedMaxTokens;
      }
    }

    // Save settings to localStorage
    function saveSettings() {
      localStorage.setItem('temperature', getTemperature());
      localStorage.setItem('max_tokens', getMaxTokens());
    }

    // Settings panel controls
    const temperatureSlider = document.getElementById('temperature-slider');
    const temperatureValue = document.getElementById('temperature-value');
    const maxTokensSlider = document.getElementById('max-tokens-slider');
    const maxTokensInput = document.getElementById('max-tokens-input');
    const maxTokensValue = document.getElementById('max-tokens-value');

    if (temperatureSlider) {
      temperatureSlider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        temperatureValue.textContent = value.toFixed(1);
        saveSettings();
      });
    }

    if (maxTokensSlider) {
      maxTokensSlider.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        maxTokensInput.value = value;
        maxTokensValue.textContent = value;
        saveSettings();
      });
    }

    if (maxTokensInput) {
      maxTokensInput.addEventListener('input', (e) => {
        let value = parseInt(e.target.value);
        // Validate that parsing succeeded (not NaN)
        if (isNaN(value)) {
          // If invalid, restore to current slider value
          value = parseInt(maxTokensSlider.value) || 2048;
          e.target.value = value;
        }
        if (value < 256) value = 256;
        if (value > 8192) value = 8192;
        maxTokensSlider.value = value;
        maxTokensValue.textContent = value;
        saveSettings();
      });
    }

    // Handle form submission
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const prompt = promptInput.value.trim();
      if (!prompt) return;

      lastPrompt = prompt; // Store for regeneration
      appendMessage('user', prompt);
      promptInput.value = '';
      sendBtn.disabled = true;
      statusEl.textContent = 'Thinking‚Ä¶';

      const typingRow = appendMessage('assistant', '', true);

      try {
        const resp = await fetch('/ask', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            prompt,
            conversation_id: currentConversationId,
            temperature: getTemperature(),
            max_tokens: getMaxTokens()
          })
        });

        if (!resp.ok) {
          // Read response body as text first (can only be read once)
          const responseText = await resp.text();
          let errorMessage = `HTTP ${resp.status}`;
          try {
            // Try to parse as JSON
            const errData = JSON.parse(responseText);
            errorMessage = errData.error || errorMessage;
          } catch {
            // If JSON parsing fails, use the text directly
            errorMessage = responseText || resp.statusText || errorMessage;
          }
          throw new Error(errorMessage);
        }

        const data = await resp.json();
        const answer = data.response || '[No response returned]';
        
        // Update conversation ID if returned
        if (data.conversation_id) {
          currentConversationId = data.conversation_id;
          sessionStorage.setItem('conversation_id', currentConversationId);
          await loadConversations();
        }

        typingRow.remove();
        appendMessage('assistant', answer);
        statusEl.textContent = 'Ready.';
      } catch (err) {
        console.error(err);
        typingRow.remove();
        appendMessage('assistant',
          'Sorry, something went wrong while contacting the backend. ' +
          'Check the server logs for details.'
        );
        statusEl.textContent = `Error: ${err.message}`;
      } finally {
        sendBtn.disabled = false;
        chat.scrollTop = chat.scrollHeight;
      }
    });

    promptInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        form.dispatchEvent(new Event('submit'));
      }
    });

    // Initialize
    newConversationBtn.addEventListener('click', createNewConversation);
    
    // Load settings and conversations on page load
    loadSettings();
    (async () => {
      await loadConversations();
      if (currentConversationId) {
        await loadConversation(currentConversationId);
      }
    })();
  </script>
</body>
</html>
